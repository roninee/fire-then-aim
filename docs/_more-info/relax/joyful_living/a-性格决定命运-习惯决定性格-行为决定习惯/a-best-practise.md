# 保持代码简单，容易理解

   是什么让代码库变得复杂？有许多事情需要考虑，但在我看来， **顶级违规者是：共享可变状态，错误抽象和低信噪比（通常由样板代码引起）。——函数式编程 **

# 把脏活留给计算机去做

   把问题简单化，别把精力放在如何抽象上，用最简单的模式，至于是否浪费内存和计算机资源放在最次要

# 速度至关重要

——为什么快速工作比看起来更重要

——"做得好"比较好，还是"做得快"比较好？

   

   鱼和熊掌不能得兼，你怎么选择：做得好，付出的代价可能是耗时长、成本高；做得快，意味着完成度低、不是精品。

   我很赞同[一篇文章](http://jsomers.net/blog/speed-matters)的结论： **做得快更好 **。

   做得快不仅可以让你在单位时间内完成更多的工作，而且 **因为你工作得很快，所以你会觉得成本低，从而倾向于做更多。 **

   写一篇博客，你可能需要两天。这是很高的时间成本，你觉得太贵了，于是你很少写。但是， **做好一件事的唯一方法，就是多做这件事。 做得越快，这件事的时间成本就越低，你会愿意做得更多。 **

   **人们总是倾向于，多消费时间成本低的东西 **。网站很快，就会多访问；搜索很快，就会多搜索；文章很容易读懂，就会多读几篇。做得快的核心，就是要让时间成本降下来，从而多做。

 

   **同时还有做的快激励的也更好，例如吃瓜子 **

   谷歌将速度作为一项功能优先考虑。他们意识到如果搜索速度很快，你就更有可能进行搜索。

 

   **对于任何待办事项列表来说都是如此。一种萎靡不振。你不断添加你永远不会交叉的物品。如果这种情况发生的话，你可能有一天会把东西放到清单上。 **

   如果我快速回复人们的电子邮件，他们会给我发送更多电子邮件。

   快速食用物品的系统可以喂食更多物品。慢速系统挨饿。

   如果客户发现您需要两个月的时间来构图，那么他们会去另一家车间。

   如果贡献者发现你合并拉请求的速度很慢，他们就会停止贡献。

   **没有反应的系统很难过。——瓜子 **

 

   即使是现在，我正在使用文本编辑器，无论出于何种原因，撤消功能突然变得缓慢。这太痛苦了。

 

   **启动任何任务所需的部分[激活能量](https://en.wikipedia.org/wiki/Activation_energy)来自于你想象中的那张照片。 **可能并不是说跑步实际上是昂贵的; 但如果感觉代价高昂，如果你头脑中的画面看起来像是一块泥泞的话，那么你需要 **更多的意志 **来装饰。

   缓慢似乎对我们头脑中的这张照片做出了特殊的贡献。 **时间特别有价值。因此，当我们了解到任务很慢时，会产生特殊的成本。每当我们想到再次完成任务时，我们就会看到它的成本和保释金。 **

这就是速度重要的原因。

 

   **处方 **必须是，如果你想要做很多事情，并且做得好，就像写，或修复错误 – 你应该尝试更快地做到这一点。

 

   这并不意味着草率。但它确实意味着， **推动自己走得比你想象的更健康 **。那是因为这项任务在 **你的脑海中会降低成本; 它会有较低的活化能 **。所以你会做得更多。当你做得更多（只要你[故意](http://jsomers.net/blog/deliberate-practice)这样做），你会变得更好。最终你会既快且好。

# 人脑并不擅长多任务

   人类的大脑本来就是为单任务设计的。虽然我们认为可以同时处理多项任务，但实际情况并非如此，我们的大脑只是在不同的任务之间来回切换而已。研究显示，长此以往会令大脑精疲力竭，还会降低人的认知能力。2007年的一项研究发现，知识型劳动者平均每3分钟就会被电子邮件或其他的干扰因素打断一次，这会导致其完成任务的能力下降。该研究估计，一家佣有5万员工的企业会因为这样的干扰损失约10亿美元，主要体现在时间减少、创造力降低、错误增加和人员倦怠等方面。得州大学达拉斯分校的Sandra Bond Chapman指出， **"科技进步重构了我们的大脑，使之沉溺于充满干扰的环境，让我们焦急地等待着收到新的邮件、短信或社交媒体内容时的提示音。" **

   **换句话说，与任何成瘾的东西一样，即便我们明知道这种干扰是有害的，但依然欲罢不能。 **

 

 

# 软件开发(以及测试)并不是标准化的

   大多数非技术人员认为软件开发是一个标准化，可重复的过程。这就是他们提出企业敏捷框架的原因。 **如果它是标准化的，我们就不需要编写软件 **，但我们会从规范[[1\]](http://blog.muhuk.com/2019/01/13/first_order_thinking_and_pragmatism_are_not_the_same_thing.html#id6)[中](http://blog.muhuk.com/2019/01/13/first_order_thinking_and_pragmatism_are_not_the_same_thing.html#id6)生成它。每个新项目，每个新任务都有一个发现组件。它需要我们在盒子外面思考。因此， **软件开发的装配线方法充其量只能产生平庸的结果。 **

 

# 测试

1：正确，以便您的测试让您对代码充满信心。

2：有效率，以便你继续运行它们并继续编写它们。—— **多快速单元测试，偶尔集成测试 **

   慢速测试和快速测试之间的区别很重要。慢速测试是集成/功能/回归/系统测试，快速测试是单元测试。 **理想情况下，您应该编写大量单元测试，以便单独测试少量代码。应谨慎使用慢速测试来测试组件之间最重要的相互作用。您可以拥有一个运行速度非常快的unittest套件和另一个包含所有测试但不一定每次运行的测试套件。 **

•   固定装置被认为是有害的。对于快速和脏的设置，如果您只需要几个对象夹具就可以了。但是对于严格的测试，动态生成模型具有优势。最重要的是，它可以更容易地完全解耦测试设置。毕竟，为每一种测试方法创建灯具是不切实际的。我最近在架构更改后难以维护灯具。[@carljm](https://twitter.com/#!/carljm)提到[factory_boy](https://github.com/rbarrois/factory_boy)，我给它一个旋转。

•   有一个很好的提示，关于 [模拟](http://pypi.python.org/pypi/mock) .patch（）' CursorWrapper在实例化时引发异常。

•   保持你的视野薄。Django拥有使这一切变得简单的所有工具。如果您查看的是超过10行代码; 想想如何将功能分成其他组件。您可以将某些代码模式化为模型方法或将其设置为模板标记/过滤器吗？基于类的视图也不一定意味着它必须自己做所有事情。

•   **测试客户端认为有害。我一直在避免使用测试客户端，除非我真的需要。 **它对Django的内部结构知之甚多，因此它比Selenium测试更不自信。我之前不知道 [WebTest](http://pypi.python.org/pypi/django-webtest)。它将WSGI与您的代码进行了对话，因此它对内部结构一无所知。

•   多步测试适用于n00bs。 **编写许多重点测试而不是串联断言。它将使维护和调试更容易。 **

# 复杂系统不可预测，也无法维护。

   可是事实上，你最多只能预测到未来几秒钟之内的情况。因为有些非常小的影响----桌面不平、桌子木头上有小凹陷之类的问题，都会使情况发生变化。过不了多久，你那些精确的计算就会不灵了。结果便证明了， **像在桌上玩撞球这种简单系统也具有不可预测的表现。" **

   这等于创造出了一个地球上不存在的世界，并让其持续运转， **势必引入了空前的复杂性。 **

   复杂系统受到太多的变量影响，任何一个变量发生异常，都可能引发连锁反应。

   **你可能会说，只要严格管理，就能避免这类错误，比如引入更加完善的权限控制、建立备用供电线路等等。但是这样一来，系统的复杂性就进一步增加了，相当于 为了防止一个按钮失败，又额外引入了更多的按钮。 **

 

# 面向对象的程序设计 - 万亿美元的灾难

   使用类看起来很有层次，但是一旦规模增加，就会增加复杂性，使得常规开发实践（如重构和测试）变得非常困难。

 

 **OOP对于人类大脑来说并不自然，我们的思维过程以“做”事为中心 ** - 散步，与朋友交谈，吃披萨。我们的大脑已经发展为做事 **，而不是将世界组织成抽象对象的复杂层次结构。 **

OOP代码是非确定性的

OOP代码鼓励使用共享可变状态，这已经被证明是一次又一次不安全。

 **功能编程确实做得很好的一件事是它有助于我们编写可靠的软件。对调试器的需求几乎完全消失。是的，无需单步调试代码并观察变量。我个人没有在很长一段时间内触及调试器。 **

 **最重要的想法是消息传递。 **

如果代码库变得太复杂且不可维护，那么即使100％的测试覆盖率也没有价值。

 **是什么让代码库变得复杂？有许多事情需要考虑，但在我看来，顶级违规者是：共享可变状态，错误抽象和低信噪比（通常由样板代码引起）。 **

 **

 **状态本身是无害的。然而，可变状态是大罪犯。 **你知道，试着理解并记住你在调用方法时会发生什么，以及副作用是什么。 **

 

然而，我们的大脑与状态合作非常糟糕，因为我们在工作记忆中一次只能容纳 **5**件物品。

、不幸的是，可变状态的精神杂耍是 **OOP **的核心。对象存在方法的唯一目的是改变同一个对象。

 **OOP **通过在整个程序中分散状态，使代码组织问题更加严重 **

 **OOP **中必须记住当前正在使用的所有对象的状态。 **

 **滥用共享状态 **——现实中，你画了一幅画，不可能让别人来和你一起画，不过现实中毕竟有时候我们确实需要和别人合作。所以这里说是滥用。

 **随着代码库不断增长，这使得程序的推理变得越来越难。 **

为了让我们的生活更轻松， **最好只有一小部分代码库处理状态 **

 **并发问题——在OOP代码中混杂共享可变状态使得这样的代码几乎不可能并行化。 **

 **并非所有的状态都是邪恶的 **——拥有不可变的数据传输对象也是完全没问题的。这里的 **关键是“不可变”。然后使用这些对象在函数之间传递数据。 **

封装是 **OOP 的特洛伊木马。它通过使其看起来安全来销售共享可变状态的想法。 **

 **封装实际上是美化的全局状态。 **

现实世界建模的问题————

有人说OOP试图模拟现实世界。这根本不是真的--OOP在现实世界中没有任何关系。尝试将程序建模为对象可能是最大的OOP错误之一。

现实世界不是等级的

OOP尝试将所有内容建模为对象的层次结构。不幸的是，这不是现实世界中的事情。 **现实世界中的对象使用消息相互交互，但它们大多彼此独立。 **

在现实世界中的继承

OOP **继承不是在现实世界之后建模的。现实世界中的父对象无法在运行时更改子对象的行为。即使你从父母那里继承了你的 **DNA **，他们也无法随心所欲地改变你的 **DNA **。你没有从父母那里继承 **“**行为 **”**，你就会发展自己的行为。你无法 **“**超越 **”**你父母的行为。

作为一个人，你也没有 **“**写 **”**方法 – 你根据外部事件或内部想法写一些文字。 **函数和数据结构属于完全不同的世界。 **

在非 **OOP **语言中，执行诸如将数据保存到文件之类的简单操作非常简单 – 与您用简单英语描述操作的方式非常相似。

当然，回到画家的例子，画家拥有一个PaintingFactory。他已经聘请了一个专门的BrushManager，ColorManager，一CanvasManager和MonaLisaProvider。他的好朋友僵尸利用了一个BrainConsumingStrategy 。这些对象，反过来，定义了以下方法：CreatePainting，FindBrush，PickColor，CallMonaLisa，和ConsumeBrainz。

当然，这很简单，在现实世界中永远不会发生。 **绘制绘画的简单行为创造了多少不必要的复杂性？ **

# **单元测试——但OOP代码非常难以进行单元测试。单元测试假定单独测试事物，并使方法可单元测试：

\1.   它的依赖关系必须被提取到一个单独的类中。

\2.   为新创建的类创建一个接口。

\3.   声明字段以保存新创建的类的实例。

\4.   利用模拟框架来模拟依赖项。

\5.   利用依赖注入框架来注入依赖项。

为了使一段代码可测试，还需要创建多少复杂性？浪费了多少时间才能使一些代码可测试？

> PS **我们还必须实例化整个类才能测试单个方法。这也将引入其所有父类的代码。

 **Boilerplate **代码 **

在信噪比方面， **Boilerplate **代码可能是最大的攻击者。 **Boilerplate **代码是使程序编译所需的 **“**噪音 **”**。 **Boilerplate **代码需要时间来编写，并且由于增加了噪声，使得代码库的可读性降低。

# 用而求学，边用边学

人说学以致用,我倒是用而求学。要 说我的读书牛活,其实就是一面工作,一 面学习的过程。书到用时方恨少,我是为 了用而逼着自己去学的。——为用而学

练习

杨 医生在脑中重复手术的步骤，实习医生格蕾s10e19

配音技巧，也不过是熟练

不断的练习使之成为习惯

我亦无他 唯手熟尔